#pragma clang diagnostic push
#pragma ide diagnostic ignored "hicpp-signed-bitwise"//位操作校验
#pragma ide diagnostic ignored "cert-err58-cpp"//STCAN_MSG报错
#pragma ide diagnostic ignored "OCUnusedGlobalDeclarationInspection"//未使用全局变量，取消对部分BUSMASTER功能检查
/* This file is generated by BUSMASTER */
/* VERSION [1.2] */
/* BUSMASTER VERSION [3.2.2] */
/* PROTOCOL [CAN] */

/* Start BUSMASTER include header */
#include "CANIncludes.h"
#include <cctype>
#include <cstring>
/* End BUSMASTER include header */

/* Start BUSMASTER Function Prototype  */
GCC_EXTERN void GCC_EXPORT OnMsgID_07e8(STCAN_MSG RxMsg);//EMS反馈
GCC_EXTERN void GCC_EXPORT OnTimer_msgSend_2701();
GCC_EXTERN void GCC_EXPORT OnTimer_msgSend_30();
GCC_EXTERN void GCC_EXPORT OnTimer_timer_Stop();
GCC_EXTERN void GCC_EXPORT OnTimer_WaitForRespTimer();
GCC_EXTERN void GCC_EXPORT OnTimer_msgSend_3E();
GCC_EXTERN void GCC_EXPORT OnTimer_msgSend_1001();
GCC_EXTERN void GCC_EXPORT OnTimer_msgSend_1003();
GCC_EXTERN void GCC_EXPORT OnTimer_msgSend();
GCC_EXTERN void GCC_EXPORT OnTimer_msgSend_CF();
GCC_EXTERN void GCC_EXPORT OnTimer_checkDTC();
GCC_EXTERN void GCC_EXPORT OnTimer_waiting();
GCC_EXTERN void GCC_EXPORT OnTimer_checkInformation();
GCC_EXTERN void GCC_EXPORT OnTimer_WaitForRespTimer_Options();
GCC_EXTERN void GCC_EXPORT OnTimer_msgSend_1101();
GCC_EXTERN void GCC_EXPORT OnTimer_msgSend_IGON();
GCC_EXTERN void GCC_EXPORT OnTimer_msgSend_IGOFF();

void Utils_Stop();

void Utils_SendMsg();

void Utils_Seed2Key_EMS(const unsigned char seedArr[], unsigned char keyArr[]);

void Utils_getNRCInfo(short NRC, char strNRC[]);

void Utils_getRoutineInfo(unsigned short RoutingStatus, char strInfo[]);

void Utils_getVehicleInfo(unsigned short VehicleStatus, char strInfo[]);

void Utils_getDTCInfo(long DTCInfo, char strInfo[]);

void Utils_getDTCStatus(long DTCStatus);

void Utils_getDTC();

void Utils_getInformation();

void Utils_checkMessage(STCAN_MSG &msg);

void Utils_RunFlowControl();

void Utils_setTimerWithResp(char *t, long duration, unsigned short wSID);

void Utils_setTimerWithRespOptions(char *t, long duration, unsigned short wSID, unsigned long wOptions);

void Utils_setTimerWaiting(char *t, long duration, unsigned short wSID, unsigned long wOptions, unsigned char jS);

short Utils_ReadVIN();

void Utils_doSecAccess();

short Utils_checkVIN();

void Utils_doWriteVIN();

void Utils_doGetInformation();

void Utils_initialize();

void Utils_PreStart();

void Utils_ascii2hex(const unsigned char chr[], unsigned char hexnumber[]);

GCC_EXTERN void GCC_EXPORT OnBus_Connect();
GCC_EXTERN void GCC_EXPORT OnKey_o();
GCC_EXTERN void GCC_EXPORT OnKey_p();
GCC_EXTERN void GCC_EXPORT OnKey_q();
GCC_EXTERN void GCC_EXPORT OnKey_r();
GCC_EXTERN void GCC_EXPORT OnKey_z();
/* End BUSMASTER Function Prototype  */

/* Start BUSMASTER Function Wrapper Prototype  */
/* End BUSMASTER Function Wrapper Prototype  */

/* Start BUSMASTER global variable */

namespace global {
    const static short False = 0;
    const static short True = 1;
    static char VIN[20];
    static unsigned char vinArr[17];
    static unsigned char PIN[4];
    static unsigned char ESK[16];//H32B算法
    static unsigned char ESK2[16];//H33D算法
    static unsigned char rInformation[100];//unsigned char无法使用strlen
    static unsigned short rInformation_rst = False;
    static unsigned short rInformation_type;
    static unsigned short rInformation_Options;
    STCAN_MSG rstMsg_EMS;
    STCAN_MSG present_EMS;
    static unsigned short IMMO_Status;
    static unsigned short Vehicle_Status;
    static unsigned char DTC_info[1000];
    static unsigned short DTC_rst = False;
    static unsigned short DTC_bytes;
//    STCAN_MSG rstMsg_BCM;
//    STCAN_MSG present_BCM;
//    STCAN_MSG rstMsg_PEPS;
//    STCAN_MSG present_PEPS;

    /*流程控制相关变量*/
    static unsigned char Mode = 0x00;
    static unsigned short testPresentCycle = 4050;
    static unsigned char Step = 0;
    static unsigned short ReSendMsg = False;
    static unsigned char WaitForRespSID;
    static unsigned long WaitForRespOptions;
    static unsigned char jStep;
    static unsigned short CFTime = 20;//连续帧间隔时间
    static unsigned short CFCount = 8;//连续帧帧数
    static unsigned short CFSend = 0;//连续帧帧数

    //static unsigned long WaitForRespCode;  // 步骤识别码

    /*计时器*/
    char msgSend_2701[] = "OnTimer_msgSend_2701";
    char msgSend_30[] = "OnTimer_msgSend_30";
    char msgSend_3E[] = "OnTimer_msgSend_3E";
    char timer_Stop[] = "OnTimer_timer_Stop";
    char WaitForRespTimer[] = "OnTimer_WaitForRespTimer";
    char msgSend_1001[] = "OnTimer_msgSend_1001";
    char msgSend_1003[] = "OnTimer_msgSend_1003";
    char msgSend[] = "OnTimer_msgSend";
    char msgSend_CF[] = "OnTimer_msgSend_CF";
    char checkDTC[] = "OnTimer_checkDTC";
    char waiting[] = "OnTimer_waiting";
    char checkInformation[] = "OnTimer_checkInformation";
    char WaitForRespTimer_Options[] = "OnTimer_WaitForRespTimer_Options";
    char msgSend_1101[] = "OnTimer_msgSend_1101";
    char msgSend_IGON[] = "OnTimer_msgSend_IGON";
    char msgSend_IGOFF[] = "OnTimer_msgSend_IGOFF";

    static unsigned char mSID = 0x00;
    static unsigned long Options = 0x00;
    static unsigned short byteCount, msgCount;//流控参数

}

using namespace global;

/* End BUSMASTER global variable */

/* Start BUSMASTER generated function - OnMsgID_07e8 */
void OnMsgID_07e8(STCAN_MSG RxMsg) {
    static unsigned char btSeed[4];
    static unsigned char btKey[4];
    //static char NRCinfoOutput[200];

    static char NRCinfo[100];
    static short NRCcode;
    //static char RespInfo[100];
    // static char RespInfoOutput[200];
    if (RxMsg.data[1] == 0x7e) { return; }
    rstMsg_EMS.id = 0x7e0;//防止ID错误
    Utils_checkMessage(RxMsg);
    switch (mSID) {
        /* 7F反馈 */
        case 0x7f:
            NRCcode = RxMsg.data[3];
            Utils_getNRCInfo(NRCcode, NRCinfo);
            Trace(">> 检测到负响应:SID=%02X,NRCcode=%02X,\nNRCinfo=%s.\n", RxMsg.data[2], NRCcode, NRCinfo);
            //ReSendMsg = True;
//                mSID = 0x00;//重置mSID,防止连续帧一直报错
            return;

            /*  27反馈 */
        case 0x67:
            Options = RxMsg.data[2];
            switch (Options) {
                /* 27 01响应，解密 */
                case 0x01:
                    btSeed[0] = (unsigned char) RxMsg.data[3];
                    btSeed[1] = (unsigned char) RxMsg.data[4];
                    btSeed[2] = (unsigned char) RxMsg.data[5];
                    btSeed[3] = (unsigned char) RxMsg.data[6];
                    Utils_Seed2Key_EMS(btSeed, btKey);
                    rstMsg_EMS.dlc = 8;
                    rstMsg_EMS.id = 0x7e0;
                    rstMsg_EMS.data[0] = 0x06;
                    rstMsg_EMS.data[1] = 0x27;
                    rstMsg_EMS.data[2] = 0x02;
                    rstMsg_EMS.data[3] = btKey[0];
                    rstMsg_EMS.data[4] = btKey[1];
                    rstMsg_EMS.data[5] = btKey[2];
                    rstMsg_EMS.data[6] = btKey[3];
                    rstMsg_EMS.data[7] = 0xFF;
                    Utils_SendMsg();
                    return;

                    /* 27 02响应，解密通过 */
                case 0x02:
                    Trace(">>安全认证通过");
                    return;
                default:
                    return;
            }

            /*22反馈*/
        case 0x62:
            memset(rInformation, 0, sizeof(rInformation));
            if (RxMsg.data[0] < 0x08) {
                Options = RxMsg.data[2] << 8 | RxMsg.data[3];
            } else {
                Options = RxMsg.data[3] << 8 | RxMsg.data[4];
                mSID = 0x00;//防止30重复调用
            }
            rInformation_type = 0x62;
            rInformation_Options = Options;
//            Trace("Options:%X",Options);
            if (Options == 0x0605) {
                IMMO_Status = RxMsg.data[4];
                switch (IMMO_Status) {
                    case 0x01:
                        Trace("ECU防盗状态：Learnt");
                        return;
                    case 0x00:
                        Trace("ECU防盗状态：Virgin");
                        return;
                    default:
                        return;
                }
            }
            if ((Options >= 0xf187 && Options <= 0xf19F) || Options == 0xfd5b || Options == 0xfd5c) {
                if (RxMsg.data[0] > 0x08) {
                    for (int i = 0; i < 6; i++) {
                        rInformation[i] = RxMsg.data[2 + i];
                    }
//                    Trace("Information:%02X %02X %02X %02X %02X %02X", rInformation[0], rInformation[1], rInformation[2], rInformation[3], rInformation[4], rInformation[5]);
                    rInformation_rst = True;
//                        byteCount = RxMsg.data[1];
//                    Trace("rInformation_rst=%02X",rInformation_rst);
//                    Trace("byteCount=%02X",byteCount);
//                    Trace("Options:%02X",Options);
                } else {
                    for (int i = 0; i < byteCount; i++) {
                        rInformation[i] = RxMsg.data[1 + i];
                    }
//                        Trace("Information:%02X %02X %02X %02X %02X %02X", rInformation[0], rInformation[1], rInformation[2], rInformation[3], rInformation[4], rInformation[5]);
                }
                settimer_CAPL(MSEC_TIMER, checkInformation, 300);
            }

            return;

            /*49反馈*/
        case 0x49:
            memset(rInformation, 0, sizeof(rInformation));
            if (RxMsg.data[0] < 0x08) {
                Options = RxMsg.data[2];
            } else {
                Options = RxMsg.data[3];
                mSID = 0x00;//防止30重复调用
            }
            rInformation_type = 0x49;
            rInformation_Options = Options;
            if (RxMsg.data[0] > 0x08) {
                for (int i = 0; i < 6; i++) {
                    rInformation[i] = RxMsg.data[2 + i];
                }
//                    Trace("Information:%02X %02X %02X %02X %02X %02X", rInformation[0], rInformation[1], rInformation[2], rInformation[3], rInformation[4], rInformation[5]);
                rInformation_rst = True;
//                        byteCount = RxMsg.data[1];
//                    Trace("rInformation_rst=%02X",rInformation_rst);
//                    Trace("byteCount=%02X",byteCount);
//                    Trace("Options:%02X",Options);
            } else {
                for (int i = 0; i < byteCount; i++) {
                    rInformation[i] = RxMsg.data[1 + i];
                }
//                        Trace("Information:%02X %02X %02X %02X %02X %02X", rInformation[0], rInformation[1], rInformation[2], rInformation[3], rInformation[4], rInformation[5]);
            }
            settimer_CAPL(MSEC_TIMER, checkInformation, 300);
            return;

            /*2E反馈*/
        case 0x6E:
            Options = (RxMsg.data[2] << 8) | RxMsg.data[3];
//              Trace("Options:%X",Options);
            return;

            /*31反馈*/
        case 0x71:
            Options = (RxMsg.data[2] << 16) | (RxMsg.data[3] << 8) | RxMsg.data[4];
//            Trace("Options:%X",Options);
            return;

        case 0x59:
//                DTC_info[100] = {};//C++11无效
//                for (int i = 0; i < 100 ; ++i) {
//                    DTC_info[i] = 0;
//                }
            memset(DTC_info, 0, sizeof(DTC_info));
            if (RxMsg.data[0] > 0x08) {
                mSID = 0x00;//防止30重复调用
                Options = RxMsg.data[3];
                for (int i = 0; i < 6; i++) {
                    DTC_info[i] = RxMsg.data[2 + i];
                }
//                    Trace("DTC:%02X %02X %02X %02X %02X %02X", DTC_info[0], DTC_info[1], DTC_info[2], DTC_info[3], DTC_info[4], DTC_info[5]);
                DTC_rst = True;
                DTC_bytes = RxMsg.data[1];
//                    Trace("DTC_rst=%02X",DTC_rst);
//                    Trace("DTC_bytes=%02X",DTC_bytes);
                settimer_CAPL(MSEC_TIMER, checkDTC, 300);
//                    Trace("Options:%02X",Options);
            } else {
                Options = RxMsg.data[2];
                if (byteCount < 0x07) {
                    Trace(">> 未发现DTC");
                } else {
                    for (int i = 0; i < byteCount; i++) {
                        DTC_info[i] = RxMsg.data[1 + i];
                    }
                    DTC_bytes = byteCount;
                    settimer_CAPL(MSEC_TIMER, checkDTC, 300);
                }
            }
            return;

        default:
            return;
    }

    //
}
/* End BUSMASTER generated function - OnMsgID_07e8 */

//on prestart
//{
//  rstMsg_ems.can = 1;
//}



/* Start BUSMASTER generated function - OnTimer_msgSend_2701 */
void OnTimer_msgSend_2701() {
    StopTimer(msgSend_2701);
    if (Mode != 0x00) {
        rstMsg_EMS.dlc = 8;
        rstMsg_EMS.data[0] = 0x02;
        rstMsg_EMS.data[1] = 0x27;
        rstMsg_EMS.data[2] = 0x01;
        rstMsg_EMS.data[3] = 0xff;
        rstMsg_EMS.data[4] = 0xff;
        rstMsg_EMS.data[5] = 0xff;
        rstMsg_EMS.data[6] = 0xff;
        rstMsg_EMS.data[7] = 0xff;
        Utils_SendMsg();
        Utils_RunFlowControl();
        return;
    }
}
/* End BUSMASTER generated function - OnTimer_msgSend_2701 */

/* Start BUSMASTER generated function - OnTimer_msgSend_30 */
void OnTimer_msgSend_30() {
    StopTimer(msgSend_30);
//    Utils_SendMsg();//会影响mSID和Options的校验
    if (msgCount != 0) {//增加判断，放置连接时自动发送
        SendMsg(rstMsg_EMS);
    }
}
/* End BUSMASTER generated function - OnTimer_msgSend_30 */

/* Start BUSMASTER generated function - OnTimer_timer_Stop */
void OnTimer_timer_Stop() {
    StopTimer(timer_Stop);
    Trace("超时，请重试");
//    StopTimer(msgSend_3E);
//    Step = 99;
//    Mode = 0x00;
//    ReSendMsg = False;
    Utils_initialize();
}
/* End BUSMASTER generated function - OnTimer_timer_Stop */

/* Start BUSMASTER generated function - OnTimer_WaitForRespTimer */
void OnTimer_WaitForRespTimer() {
    StopTimer(WaitForRespTimer);
    //Trace ("mSID=%02X,WaitForRespSID=%02X",mSID,WaitForRespSID);//测试使用
    if (Mode != 0x00) {
        if (WaitForRespSID == mSID) {
            ReSendMsg = False;
            WaitForRespSID = 0x00;
//            Trace("SID校验成功");
            Utils_RunFlowControl();
            return;
        } else {
            ReSendMsg = True;
            Trace("SID校验失败");
            Utils_RunFlowControl();
            return;
        }
    }
}
/* End BUSMASTER generated function - OnTimer_WaitForRespTimer */

/* Start BUSMASTER generated function - OnTimer_WaitForRespTimer_Options */
void OnTimer_WaitForRespTimer_Options() {
    StopTimer(WaitForRespTimer_Options);
//    Trace ("mSID=%02X,WaitForRespSID=%02X,Options=%X,WaitForRespOptions=%X",mSID,WaitForRespSID,Options,WaitForRespOptions);//测试使用
    if (Mode != 0x00) {
        if (WaitForRespSID == mSID && WaitForRespOptions == Options) {
            ReSendMsg = False;
            WaitForRespSID = 0x00;
            WaitForRespOptions = 0x00;
//            Trace("SID/Options校验成功");
            Utils_RunFlowControl();
            return;
        } else {
            ReSendMsg = True;
            Trace("SID/Options校验失败");
            Utils_RunFlowControl();
            return;
        }
    }
}
/* End BUSMASTER generated function - OnTimer_WaitForRespTimer_Options */


/* Start BUSMASTER generated function - OnTimer_msgSend_3E */
void OnTimer_msgSend_3E() {
    //StopTimer(msgSend_3E);
    if (Mode != 0x00) {
        SendMsg(present_EMS);
        return;
    }
}
/* End BUSMASTER generated function - OnTimer_msgSend_3E */

/* Start BUSMASTER generated function - OnTimer_msgSend_1001 */
void OnTimer_msgSend_1001() {
    StopTimer(msgSend_1001);
    if (Mode != 0x00) {
        rstMsg_EMS.dlc = 8;
        rstMsg_EMS.data[0] = 0x02;
        rstMsg_EMS.data[1] = 0x10;
        rstMsg_EMS.data[2] = 0x01;
        rstMsg_EMS.data[3] = 0xff;
        rstMsg_EMS.data[4] = 0xff;
        rstMsg_EMS.data[5] = 0xff;
        rstMsg_EMS.data[6] = 0xff;
        rstMsg_EMS.data[7] = 0xff;
        Utils_SendMsg();
        Utils_RunFlowControl();
        return;
    }
}
/* End BUSMASTER generated function - OnTimer_msgSend_1001 */

/* Start BUSMASTER generated function - OnTimer_msgSend_1003 */
void OnTimer_msgSend_1003() {
    StopTimer(msgSend_1003);
    if (Mode != 0x00) {
        rstMsg_EMS.dlc = 8;
        rstMsg_EMS.data[0] = 0x02;
        rstMsg_EMS.data[1] = 0x10;
        rstMsg_EMS.data[2] = 0x03;
        rstMsg_EMS.data[3] = 0xff;
        rstMsg_EMS.data[4] = 0xff;
        rstMsg_EMS.data[5] = 0xff;
        rstMsg_EMS.data[6] = 0xff;
        rstMsg_EMS.data[7] = 0xff;
        Utils_SendMsg();
        Utils_RunFlowControl();
        return;
    }
}
/* End BUSMASTER generated function - OnTimer_msgSend_1003 */

/* Start BUSMASTER generated function - OnTimer_msgSend */
void OnTimer_msgSend() {
    StopTimer(msgSend);
    if (Mode != 0x00) {
        Utils_SendMsg();
        Utils_RunFlowControl();
        return;
    }
}
/* End BUSMASTER generated function - OnTimer_msgSend */

/* Start BUSMASTER generated function - OnTimer_waiting */
void OnTimer_waiting() {
    StopTimer(waiting);
//    Trace ("mSID=%02X,WaitForRespSID=%02X,Options=%X,WaitForRespOptions=%X",mSID,WaitForRespSID,Options,WaitForRespOptions);//测试使用
    if (Mode != 0x00) {
        if (WaitForRespSID == mSID && WaitForRespOptions == Options) {
            WaitForRespSID = 0x00;
            WaitForRespOptions = 0x00;
            Utils_RunFlowControl();
            return;

        } else {
            Step = jStep;//跳步
            Utils_RunFlowControl();
            return;
        }
    }
}
/* End BUSMASTER generated function - OnTimer_waiting */

/* Start BUSMASTER generated function - OnTimer_msgSend_1101 */
void OnTimer_msgSend_1101() {
    StopTimer(msgSend_1101);
    if (Mode != 0x00) {
        rstMsg_EMS.dlc = 8;
        rstMsg_EMS.data[0] = 0x02;
        rstMsg_EMS.data[1] = 0x11;
        rstMsg_EMS.data[2] = 0x01;
        rstMsg_EMS.data[3] = 0xff;
        rstMsg_EMS.data[4] = 0xff;
        rstMsg_EMS.data[5] = 0xff;
        rstMsg_EMS.data[6] = 0xff;
        rstMsg_EMS.data[7] = 0xff;
        Utils_SendMsg();
        Utils_RunFlowControl();
        return;
    }
}
/* End BUSMASTER generated function - OnTimer_msgSend_1101 */


/* Start BUSMASTER generated function - OnTimer_msgSend_IGON */
void OnTimer_msgSend_IGON() {
    StopTimer(msgSend_IGON);
    if (Mode != 0x00) {
        rstMsg_EMS.dlc = 8;
        rstMsg_EMS.data[0] = 0x06;
        rstMsg_EMS.data[1] = 0x2f;
        rstMsg_EMS.data[2] = 0x5c;
        rstMsg_EMS.data[3] = 0xa4;
        rstMsg_EMS.data[4] = 0x03;
        rstMsg_EMS.data[5] = 0x01;
        rstMsg_EMS.data[6] = 0x01;
        rstMsg_EMS.data[7] = 0xff;
        Utils_SendMsg();
//        Utils_RunFlowControl();
        Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x6f, 0x5ca4);
        return;
    }
}
/* End BUSMASTER generated function - OnTimer_msgSend_IGON */

/* Start BUSMASTER generated function - OnTimer_msgSend_IGOFF */
void OnTimer_msgSend_IGOFF() {
    StopTimer(msgSend_IGOFF);
    if (Mode != 0x00) {
        rstMsg_EMS.dlc = 8;
        rstMsg_EMS.data[0] = 0x06;
        rstMsg_EMS.data[1] = 0x2f;
        rstMsg_EMS.data[2] = 0x5c;
        rstMsg_EMS.data[3] = 0xa4;
        rstMsg_EMS.data[4] = 0x03;
        rstMsg_EMS.data[5] = 0x00;
        rstMsg_EMS.data[6] = 0x01;
        rstMsg_EMS.data[7] = 0xff;
        Utils_SendMsg();
//        Utils_RunFlowControl();
        Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x6f, 0x5ca4);
        return;
    }
}
/* End BUSMASTER generated function - OnTimer_msgSend_IGOFF */

/* Start BUSMASTER generated function - OnTimer_msgSend_CF */
void OnTimer_msgSend_CF() {
    StopTimer(msgSend_CF);
    Step--;
    //Trace("CFSend=%d,CFCount=%d,Step=%d", CFSend, CFCount,Step);//测试使用
    if (Mode != 0x00) {
        SendMsg(rstMsg_EMS);
        if (CFSend == CFCount - 1) {
            Step++;
        }
        CFSend++;
        Utils_RunFlowControl();
        //Trace("CFSend=%d,CFCount=%d,Step=%d", CFSend, CFCount,Step);//测试使用
        return;
    }
}
/* End BUSMASTER generated function - OnTimer_msgSend_CF */

/* Start BUSMASTER generated function - OnTimer_checkDTC */
void OnTimer_checkDTC() {
    StopTimer(checkDTC);
    Utils_getDTC();
    DTC_rst = False;//防止其他多帧错误调用
    DTC_bytes = 0;
}
/* End BUSMASTER generated function - OnTimer_checkDTC */

/* Start BUSMASTER generated function - OnTimer_checkInformation */
void OnTimer_checkInformation() {
//    Trace("Options:%X",Options);
    StopTimer(checkInformation);
    Utils_getInformation();
    rInformation_rst = False;//防止其他多帧错误调用

}
/* End BUSMASTER generated function - OnTimer_checkInformation */


/* Start BUSMASTER generated function - Utils_Stop */
void Utils_Stop() {
    StopTimer(timer_Stop);
    StopTimer(msgSend_3E);
    Mode = 0x00;
}
//停止计时器3E、超时

/* Start BUSMASTER generated function - Utils_SendMsg */
void Utils_SendMsg() {
    mSID = 0x00;
    Options = 0x00;
    SendMsg(rstMsg_EMS);
}
//重置mSID、Options，并发送消息

/* End BUSMASTER generated function - Utils_SendMsg */


/* Start BUSMASTER generated function - Utils_Seed2Key_EMS */
void Utils_Seed2Key_EMS(const unsigned char seedArr[], unsigned char keyArr[]) {
    static unsigned long Seed, K1, K2, A, B, Ky;
    K1 = 542712;
    K2 = 2567;
    Seed = seedArr[3];
    Seed = Seed | (seedArr[2] << 8);
    Seed = Seed | (seedArr[1] << 16);
    Seed = Seed | (seedArr[0] << 24);
    Trace("EMS seed: %08X", Seed);
    A = K2 * Seed + K1;
    B = K2 * Seed - K1;
    Ky = A ^ B;
//    Trace("A:%x,B:%x,Ky:%x", A, B, Ky);
    keyArr[0] = (Ky >> 24) & 0xFF;
    keyArr[1] = (Ky >> 16) & 0xFF;
    keyArr[2] = (Ky >> 8) & 0xFF;
    keyArr[3] = (Ky) & 0xFF;
}
//EMS安全算法
/* End BUSMASTER generated function - Utils_Seed2Key_EMS */

/* Start BUSMASTER generated function - Utils_getNRCInfo */
void Utils_getNRCInfo(short NRC, char strNRC[]) {
    switch (NRC) {
        case 0x11:
            strcpy(strNRC, "serviceNotSupported");
            break;
        case 0x12:
            strcpy(strNRC, "subFunctionNotSupported");
            break;
        case 0x13:
            strcpy(strNRC, "incorrectMessageLengthOrInvalidFormat");
            break;
        case 0x22:
            strcpy(strNRC, "conditionNotCorrect");
            break;
        case 0x24:
            strcpy(strNRC, "requestSequenceError");
            break;
        case 0x31:
            strcpy(strNRC, "requestOutOfRange");
            break;
        case 0x33:
            strcpy(strNRC, "securityAccessDenied");
            break;
        case 0x35:
            strcpy(strNRC, "invalidKey");
            break;
        case 0x36:
            strcpy(strNRC, "exceededNumberOfAttempts");
            break;
        case 0x37:
            strcpy(strNRC, "requiredTimeDelayNotExpired ");
            break;
        case 0x72:
            strcpy(strNRC, "generalProgrammingFailure");
            break;
        case 0x78:
            strcpy(strNRC, "requestCorrectlyReceivedResponsePending");
            break;
        case 0x7e:
            strcpy(strNRC, "subFunctionNotSupportedInactiveSession");
            break;
        case 0x7f:
            strcpy(strNRC, "serviceNotSupportedInActiveSession");
            break;
        case 0x92:
            strcpy(strNRC, "voltageTooHigh");
            break;
        case 0x93:
            strcpy(strNRC, "voltageTooLow");
            break;
        default:
            strcpy(strNRC, "未定义的NRC，请查看诊断规范！");
            break;
    }
}
//NRC说明转换
/* End BUSMASTER generated function - Utils_getNRCInfo */

/* Start BUSMASTER generated function - Utils_getRoutineInfo */
void Utils_getRoutineInfo(unsigned short RoutingStatus, char strInfo[]) {
    switch (RoutingStatus) {
        case 0x00:
            strcpy(strInfo, "invalidOrDefault");
            break;
        case 0x01:
            strcpy(strInfo, "ESCL_NotAtPresent");
            break;
        case 0x02:
            strcpy(strInfo, "ECM_NotAtPresent");
            break;
        case 0x03:
            strcpy(strInfo, "ESCL_VirginECM_LearntCAPE_Learnt");
            break;
        case 0x04:
            strcpy(strInfo, "ESCL_LearntECM_VirginCAPE_Learnt");
            break;
        case 0x05:
            strcpy(strInfo, "ESCL_LearntECM_LearntCAPE_Virgin");
            break;
        case 0x06:
            strcpy(strInfo, "ESCL_VirginECM_VirginCAPE_Learnt");
            break;
        case 0x07:
            strcpy(strInfo, "ESCL_VirginECM_LearntCAPE_Virgin");
            break;
        case 0x08:
            strcpy(strInfo, "ESCL_LearntECM_VirginCAPE_Virgin");
            break;
        case 0x09:
            strcpy(strInfo, "ESCL_LearntECM_LearntCAPE_Learnt");
            break;
        case 0x0a:
            strcpy(strInfo, "AllECU_AtPresentAndVirgin");
            break;
        case 0x0b:
            strcpy(strInfo, "ESCL_LearningTimerOut");
            break;
        case 0x0c:
            strcpy(strInfo, "ESCL_ComparisonResultIsOk");
            break;
        case 0x0d:
            strcpy(strInfo, "ESCL_ComparisonResultIsError");
            break;
        case 0x0e:
            strcpy(strInfo, "ECM_LearningTimerOut");
            break;
        case 0x0f:
            strcpy(strInfo, "ECM_ComparisonResultIsOk");
            break;
        case 0x10:
            strcpy(strInfo, "ECM_ComparisonResultIsError");
            break;
        case 0x11:
            strcpy(strInfo, "SC_AccessTimeOut");
            break;
        case 0x12:
            strcpy(strInfo, "SC_AccessOk");
            break;
        case 0x13:
            strcpy(strInfo, "SC_AccessError");
            break;
        case 0x14:
            strcpy(strInfo, "verificationIsOk");
            break;
        case 0x15:
            strcpy(strInfo, "verificationFail");
            break;
        case 0x16:
            strcpy(strInfo, "UID_LearningError");
            break;
        case 0x17:
            strcpy(strInfo, "UID1_LearningFinished");
            break;
        case 0x18:
            strcpy(strInfo, "UID2_LearningFinished");
            break;
        case 0x19:
            strcpy(strInfo, "UID_Learning");
            break;
        case 0x1a:
            strcpy(strInfo, "routingWorking");
            break;
        case 0x1b:
            strcpy(strInfo, "ESCL_Virgin");
            break;
        case 0x1c:
            strcpy(strInfo, "CAPE_Virgin");
            break;
        case 0x1d:
            strcpy(strInfo, "ECM_Virgin");
            break;
        case 0x1e:
            strcpy(strInfo, "ESCL_Learnt");
            break;
        case 0x1f:
            strcpy(strInfo, "CAPE_Learnt");
            break;
        case 0x20:
            strcpy(strInfo, "ECM_Learnt");
            break;
        case 0x21:
            strcpy(strInfo, "afterSalesAuthTimeOut");
            break;
        case 0x22:
            strcpy(strInfo, "UID3_LearningFinished");
            break;
        case 0x23:
            strcpy(strInfo, "ESCLandECM_BothNotAtPresent");
            break;
        case 0x24:
            strcpy(strInfo, "UID4_LearningFinished");
            break;
        case 0x25:
            strcpy(strInfo, "UID5_LearningFinished");
            break;
        default:
            strcpy(strInfo, "未定义的PRC，请查看诊断规范！");
            break;
    }
}
//31响应说明转换
/* End BUSMASTER generated function - Utils_getRoutineInfo */

/* Start BUSMASTER generated function - Utils_getVehicleInfo */
void Utils_getVehicleInfo(unsigned short VehicleStatus, char strInfo[]) {
    switch (VehicleStatus) {
        case 0x00:
            strcpy(strInfo, "ESCL on,EMS on");
            break;
        case 0x01:
            strcpy(strInfo, "ESCL off,EMS on");
            break;
        case 0x02:
            strcpy(strInfo, "ESCL on,EMS off");
            break;
        case 0x03:
            strcpy(strInfo, "ESCL on,EMS on");
            break;
        default:
            strcpy(strInfo, "未定义的配置，请查看诊断规范！");
    }
}
//车辆配置
/* End BUSMASTER generated function - Utils_getVehicleInfo */

/* Start BUSMASTER generated function - Utils_getDTCInfo */
void Utils_getDTCInfo(long DTCInfo, char strInfo[]) {
    switch (DTCInfo) {
        case 0x001000:
            strcpy(strInfo, "进气VVT阀控制线路故障(D).");
            break;
        case 0x001100:
            strcpy(strInfo, "进气VVT位置信号不合理(C).");
            break;
        case 0x001200:
            strcpy(strInfo, "进气VVT目标及响应故障(C).");
            break;
        case 0x001300:
            strcpy(strInfo, "排气VVT阀控制线路故障(D).");
            break;
        case 0x001400:
            strcpy(strInfo, "排气VVT位置信号不合理(C).");
            break;
        case 0x001500:
            strcpy(strInfo, "排气VVT目标及响应故障(C).");
            break;
        case 0x003300:
            strcpy(strInfo, "增压控制阀开路故障(D).");
            break;
        case 0x010500:
            strcpy(strInfo, "进气压力传感器信号电路故障(D).");
            break;
        case 0x010600:
            strcpy(strInfo, "进气压力传感器信号不合理(C).");
            break;
        case 0x010700:
            strcpy(strInfo, "进气压力传感器信号电路电压过低或开路(D).");
            break;
        case 0x010800:
            strcpy(strInfo, "进气压力传感器线路电压过高(C).");
            break;
        case 0x011000:
            strcpy(strInfo, "进气温度传感器信号电路故障(D).");
            break;
        case 0x011100:
            strcpy(strInfo, "进气温度传感器信号不合理(C).");
            break;
        case 0x011200:
            strcpy(strInfo, "进气温度传感器信号电路电压过低(C).");
            break;
        case 0x011300:
            strcpy(strInfo, "进气温度传感器信号电路电压过高或开路(D).");
            break;
        case 0x011500:
            strcpy(strInfo, "冷却液温度传感器信号电路故障(D).");
            break;
        case 0x011600:
            strcpy(strInfo, "冷却液温度传感器信号不合理(C).");
            break;
        case 0x011700:
            strcpy(strInfo, "冷却液温度传感器信号电路电压过低(C).");
            break;
        case 0x011800:
            strcpy(strInfo, "冷却液温度传感器信号电路电压过高或开路(D).");
            break;
        case 0x012000:
            strcpy(strInfo, "节气门传感器信号电路故障(D).");
            break;
        case 0x012100:
            strcpy(strInfo, "节气门传感器信号不合理(C).");
            break;
        case 0x012200:
            strcpy(strInfo, "节气门传感器信号电路电压过低或开路(D).");
            break;
        case 0x012300:
            strcpy(strInfo, "节气门传感器信号电路电压过高(C).");
            break;
        case 0x012800:
            strcpy(strInfo, "节温器信号开路故障(C).");
            break;
        case 0x013000:
            strcpy(strInfo, "前氧传感器信号不合理(C).");
            break;
        case 0x013100:
            strcpy(strInfo, "前氧传感器线路电压太低或短路(C).");
            break;
        case 0x013200:
            strcpy(strInfo, "前氧传感器线路电压太高(C).");
            break;
        case 0x013300:
            strcpy(strInfo, "前氧传感器反应老化(C).");
            break;
        case 0x013400:
            strcpy(strInfo, "前氧传感器线路故障(D).");
            break;
        case 0x013500:
            strcpy(strInfo, "前氧传感器的加热线路故障(D).");
            break;
        case 0x013600:
            strcpy(strInfo, "后氧传感器信号不合理(C).");
            break;
        case 0x013700:
            strcpy(strInfo, "后氧传感器线路电压太低或短路(C).");
            break;
        case 0x013800:
            strcpy(strInfo, "后氧传感器线路电压太高(C).");
            break;
        case 0x013900:
            strcpy(strInfo, "后氧传感器反应老化(C).");
            break;
        case 0x014000:
            strcpy(strInfo, "后氧传感器线路故障(D).");
            break;
        case 0x014100:
            strcpy(strInfo, "后氧传感器加热线路故障(D).");
            break;
        case 0x015100:
            strcpy(strInfo, "后氧传感器电压低(兼容).");
            break;
        case 0x015200:
            strcpy(strInfo, "后氧传感器电压高(兼容).");
            break;
        case 0x015400:
            strcpy(strInfo, "后氧传感器线路故障(兼容).");
            break;
        case 0x015500:
            strcpy(strInfo, "后氧传感器加热线路故障(兼容).");
            break;
        case 0x017000:
            strcpy(strInfo, "燃油系统修正值不合理(C).");
            break;
        case 0x017100:
            strcpy(strInfo, "燃油系统过稀故障(C).");
            break;
        case 0x017200:
            strcpy(strInfo, "燃油系统过浓故障(C).");
            break;
        case 0x020100:
            strcpy(strInfo, "一缸喷油器控制电路故障(D).");
            break;
        case 0x020200:
            strcpy(strInfo, "二缸喷油器控制电路故障(D).");
            break;
        case 0x020300:
            strcpy(strInfo, "三缸喷油器控制电路故障(D).");
            break;
        case 0x020400:
            strcpy(strInfo, "四缸喷油器控制电路故障(D).");
            break;
        case 0x023000:
            strcpy(strInfo, "油泵继电器控制电路故障(F).");
            break;
        case 0x023500:
            strcpy(strInfo, "增压压力传感器线路故障(D).");
            break;
        case 0x023600:
            strcpy(strInfo, "增压压力传感器信号不合理(C).");
            break;
        case 0x023700:
            strcpy(strInfo, "增压压力传感器信号电路电压过低或开路(D).");
            break;
        case 0x023800:
            strcpy(strInfo, "增压压力传感器信号电路电压过高(C).");
            break;
        case 0x023900:
            strcpy(strInfo, "增压温度传感器线路故障(D).");
            break;
        case 0x024000:
            strcpy(strInfo, "增压温度传感器信号不合理(C).");
            break;
        case 0x024100:
            strcpy(strInfo, "增压温度传感器信号电压过低(C).");
            break;
        case 0x024200:
            strcpy(strInfo, "增压温度传感器信号电压过高或开路(D).");
            break;
        case 0x024300:
            strcpy(strInfo, "泄压控制阀开路故障(D).");
            break;
        case 0x030000:
            strcpy(strInfo, "发动机多缸失火(B).");
            break;
        case 0x030100:
            strcpy(strInfo, "发动机1缸失火(B).");
            break;
        case 0x030200:
            strcpy(strInfo, "发动机2缸失火(B).");
            break;
        case 0x030300:
            strcpy(strInfo, "发动机3缸失火(B).");
            break;
        case 0x030400:
            strcpy(strInfo, "发动机4缸失火(B).");
            break;
        case 0x032500:
            strcpy(strInfo, "爆震传感器信号电路故障(D).");
            break;
        case 0x033500:
            strcpy(strInfo, "曲轴58X传感器信号电路故障(D).");
            break;
        case 0x033600:
            strcpy(strInfo, "曲轴58X传感器信号不合理(C).");
            break;
        case 0x034000:
            strcpy(strInfo, "进气凸轮轴传感器信号电路故障(D).");
            break;
        case 0x034100:
            strcpy(strInfo, "进气凸轮轴传感器信号不合理(C).");
            break;
        case 0x034500:
            strcpy(strInfo, "排气凸轮轴传感器信号电路故障(D).");
            break;
        case 0x034600:
            strcpy(strInfo, "排气凸轮轴传感器信不合理(C).");
            break;
        case 0x035100:
            strcpy(strInfo, "点火线圈A组控制电路故障(D).");
            break;
        case 0x035200:
            strcpy(strInfo, "点火线圈B组控制电路故障(D).");
            break;
        case 0x035300:
            strcpy(strInfo, "点火线圈C组控制电路故障(D).");
            break;
        case 0x035400:
            strcpy(strInfo, "点火线圈D组控制电路故障(D).");
            break;
        case 0x040100:
            strcpy(strInfo, "EGR清洗功能故障(C).");
            break;
        case 0x040300:
            strcpy(strInfo, "EGR控制输出电路故障(D).");
            break;
        case 0x040500:
            strcpy(strInfo, "EGR信号电路电压过低或开路(D).");
            break;
        case 0x040600:
            strcpy(strInfo, "EGR信号电路电压过高(C).");
            break;
        case 0x042000:
            strcpy(strInfo, "三元催化器储氧能力老化（排放超限）(C).");
            break;
        case 0x042700:
            strcpy(strInfo, "GPF入口温度传感器信号电路电压过低(C).");
            break;
        case 0x042800:
            strcpy(strInfo, "GPF入口温度传感器信号电路电压过高(D).");
            break;
        case 0x044100:
            strcpy(strInfo, "脱附流量故障(C).");
            break;
        case 0x044200:
            strcpy(strInfo, "油箱泄露故障（少量泄漏）(C).");
            break;
        case 0x044300:
            strcpy(strInfo, "碳罐电磁阀控制电路故障(D).");
            break;
        case 0x044600:
            strcpy(strInfo, "碳罐截止阀控制电路故障(D).");
            break;
        case 0x044900:
            strcpy(strInfo, "炭罐冲洗阀输出电路故障(D).");
            break;
        case 0x045000:
            strcpy(strInfo, "油箱压力传感器信号故障(D).");
            break;
        case 0x045100:
            strcpy(strInfo, "油箱压力传感器信号不合理(C).");
            break;
        case 0x045200:
            strcpy(strInfo, "油箱压力传感器信号电路电压过低或开路(D).");
            break;
        case 0x045300:
            strcpy(strInfo, "油箱压力传感器信号电路电压过高(C).");
            break;
        case 0x045500:
            strcpy(strInfo, "油箱泄露故障（油箱盖）(C).");
            break;
        case 0x046200:
            strcpy(strInfo, "油量传感器信号电压低(E).");
            break;
        case 0x046300:
            strcpy(strInfo, "油量传感器信号电压高或开路(E).");
            break;
        case 0x047000:
            strcpy(strInfo, "GPF压力传感器开路故障(D).");
            break;
        case 0x047200:
            strcpy(strInfo, "GPF压力传感器信号电路电压过低(D).");
            break;
        case 0x047300:
            strcpy(strInfo, "GPF压力传感器信号电路电压过高(C).");
            break;
        case 0x047400:
            strcpy(strInfo, "GPF压力传感器压力不稳定(C).");
            break;
        case 0x048000:
            strcpy(strInfo, "低速冷却风扇控制线路故障(F).");
            break;
        case 0x048100:
            strcpy(strInfo, "高速冷却风扇控制线路故障(F).");
            break;
        case 0x049600:
            strcpy(strInfo, "CPV阀卡死在开位置(C).");
            break;
        case 0x049700:
            strcpy(strInfo, "CPV阀卡死在关位置(C).");
            break;
        case 0x050000:
            strcpy(strInfo, "车速传感器信号电路故障(F).");
            break;
        case 0x050200:
            strcpy(strInfo, "转速输出信号电路故障(F).");
            break;
        case 0x050400:
            strcpy(strInfo, "制动开关相关性故障(F).");
            break;
        case 0x050500:
            strcpy(strInfo, "怠速控制系统线路故障(D).");
            break;
        case 0x050600:
            strcpy(strInfo, "怠速控制转速低于目标怠速(C).");
            break;
        case 0x050700:
            strcpy(strInfo, "怠速控制转速高于目标怠速(C).");
            break;
        case 0x050B00:
            strcpy(strInfo, "点火效率故障(C).");
            break;
        case 0x050D00:
            strcpy(strInfo, "低怠速故障(C).");
            break;
        case 0x051A00:
            strcpy(strInfo, "曲轴箱压力传感器电路故障(D).");
            break;
        case 0x051B00:
            strcpy(strInfo, "曲轴箱压力传感器电路不合理(C).");
            break;
        case 0x051C00:
            strcpy(strInfo, "曲轴箱压力传感器电路低(D).");
            break;
        case 0x051D00:
            strcpy(strInfo, "曲轴箱压力传感器电路高(C).");
            break;
        case 0x051E00:
            strcpy(strInfo, "曲轴箱压力传感器电路间歇(C).");
            break;
        case 0x051F00:
            strcpy(strInfo, "曲轴箱通风管脱落故障(C).");
            break;
        case 0x053500:
            strcpy(strInfo, "空调温度传感器信号电路故障(F).");
            break;
        case 0x053700:
            strcpy(strInfo, "空调温度传感器信号电路电压过低(F).");
            break;
        case 0x053800:
            strcpy(strInfo, "空调温度传感器信号电路电压过高(F).");
            break;
        case 0x056100:
            strcpy(strInfo, "系统电压不合理(F).");
            break;
        case 0x056200:
            strcpy(strInfo, "系统蓄电池电压过低(F).");
            break;
        case 0x056300:
            strcpy(strInfo, "系统蓄电池电压过高(F).");
            break;
        case 0x057500:
            strcpy(strInfo, "定速巡航开关线路故障(F).");
            break;
        case 0x057600:
            strcpy(strInfo, "定速巡航开关线路电压低(F).");
            break;
        case 0x057700:
            strcpy(strInfo, "定速巡航开关线路电压高(F).");
            break;
        case 0x057800:
            strcpy(strInfo, "定速巡航开关线路失效(F).");
            break;
        case 0x061500:
            strcpy(strInfo, "起动继电器控制线路故障(F).");
            break;
        case 0x064500:
            strcpy(strInfo, "空调继电器控制线路故障(F).");
            break;
        case 0x065000:
            strcpy(strInfo, "故障指示灯（MIL）线路失效(F).");
            break;
        case 0x065600:
            strcpy(strInfo, "油位输出信号线路故障(F).");
            break;
        case 0x080700:
            strcpy(strInfo, "离合器开关线路低电压(F).");
            break;
        case 0x080800:
            strcpy(strInfo, "离合器开关线路高电压(F).");
            break;
        case 0x080900:
            strcpy(strInfo, "空档开关失效(F).");
            break;
        case 0x100000:
            strcpy(strInfo, "GPF堵塞(兼容).");
            break;
        case 0x100100:
            strcpy(strInfo, "GPF移除或损坏(兼容).");
            break;
        case 0x100200:
            strcpy(strInfo, "基于压差的Ash过载(C).");
            break;
        case 0x100300:
            strcpy(strInfo, "基于模型的Ash过载(C).");
            break;
        case 0x100500:
            strcpy(strInfo, "基于压差的soot过载(C).");
            break;
        case 0x100600:
            strcpy(strInfo, "基于模型的soot过载(C).");
            break;
        case 0x100700:
            strcpy(strInfo, "soot过载(C).");
            break;
        case 0x100800:
            strcpy(strInfo, "催化器损坏失火(A).");
            break;
        case 0x100900:
            strcpy(strInfo, "点火效率故障(兼容).");
            break;
        case 0x100A00:
            strcpy(strInfo, "低怠速故障(兼容).");
            break;
        case 0x100B00:
            strcpy(strInfo, "PDA控制电路故障(D).");
            break;
        case 0x100C00:
            strcpy(strInfo, "SVS指示灯输出信号电路故障(E).");
            break;
        case 0x100D00:
            strcpy(strInfo, "真空泵输出继电器故障(F).");
            break;
        case 0x101400:
            strcpy(strInfo, "大气压力传感器电路故障(F).");
            break;
        case 0x101500:
            strcpy(strInfo, "大气压力传感器信号不合理(F).");
            break;
        case 0x101600:
            strcpy(strInfo, "大气压力传感器信号电路电压过低(F).");
            break;
        case 0x101700:
            strcpy(strInfo, "大气压力传感器信号电路电压过高(F).");
            break;
        case 0x101800:
            strcpy(strInfo, "水温信号输出电路故障(F).");
            break;
        case 0x101900:
            strcpy(strInfo, "电子水泵输出继电器故障(F).");
            break;
        case 0x110100:
            strcpy(strInfo, "ABS通讯丢失(F).");
            break;
        case 0x110200:
            strcpy(strInfo, "ESC通讯丢失(F).");
            break;
        case 0x110300:
            strcpy(strInfo, "BCM通讯丢失(F).");
            break;
        case 0x110400:
            strcpy(strInfo, "IPC通讯丢失(F).");
            break;
        case 0x113000:
            strcpy(strInfo, "外发报文中车速信号异常(F).");
            break;
        case 0x113100:
            strcpy(strInfo, "外发报文中发动机转速信号异常(F).");
            break;
        case 0x152300:
            strcpy(strInfo, "安全气囊信号异常(F).");
            break;
        case 0x161100:
            strcpy(strInfo, "PIN码输入错误(F).");
            break;
        case 0x161200:
            strcpy(strInfo, "PEPS无响应(F).");
            break;
        case 0x161300:
            strcpy(strInfo, "PEPS钥匙认证失败(F).");
            break;
        case 0x200200:
            strcpy(strInfo, "GPF堵塞(C).");
            break;
        case 0x210000:
            strcpy(strInfo, "电子节气门线路故障(D).");
            break;
        case 0x210800:
            strcpy(strInfo, "电子节气门响应慢(C).");
            break;
        case 0x210900:
            strcpy(strInfo, "电子节气门最小位置自学习故障(C).");
            break;
        case 0x211000:
            strcpy(strInfo, "电子节气门最大位置自学习故障(C).");
            break;
        case 0x212000:
            strcpy(strInfo, "踏板位置传感器线路故障(D).");
            break;
        case 0x212100:
            strcpy(strInfo, "踏板位置传感器信号电路不合理(F).");
            break;
        case 0x212200:
            strcpy(strInfo, "踏板位置传感器信号电路电压过低(F).");
            break;
        case 0x212300:
            strcpy(strInfo, "踏板位置传感器信号电路电压过高(F).");
            break;
        case 0x217600:
            strcpy(strInfo, "电子节气门复位故障(F).");
            break;
        case 0x218400:
            strcpy(strInfo, "冷却风扇端冷液温度传感器电压信号过低(C).");
            break;
        case 0x218500:
            strcpy(strInfo, "冷却风扇端冷液温度传感器电压信号过高或开路(D).");
            break;
        case 0x218700:
            strcpy(strInfo, "怠速工况燃油系统过稀(C).");
            break;
        case 0x218800:
            strcpy(strInfo, "怠速工况燃油系统过浓(C).");
            break;
        case 0x226D00:
            strcpy(strInfo, "GPF移除或损坏(C).");
            break;
        case 0x242100:
            strcpy(strInfo, "CCV阀卡死在开位置(C).");
            break;
        case 0x242200:
            strcpy(strInfo, "CCV阀卡死在关位置(C).");
            break;
        case 0x242F00:
            strcpy(strInfo, "Ash过载(C).");
            break;
        case 0x245200:
            strcpy(strInfo, "GPF相对压力传感器开路故障(D).");
            break;
        case 0x245300:
            strcpy(strInfo, "GPF压力传感器上游管路脱落故障(C).");
            break;
        case 0x245400:
            strcpy(strInfo, "GPF相对压力传感器电压低(D).");
            break;
        case 0x245500:
            strcpy(strInfo, "GPF相对压力传感器电压高(C).");
            break;
        case 0x245600:
            strcpy(strInfo, "GPF相对压力传感器压力不稳定(C).");
            break;
        case 0x245F00:
            strcpy(strInfo, "GPF压力传感器下游管路脱落故障(C).");
            break;
        case 0x252500:
            strcpy(strInfo, "真空泵压力传感器信号电路故障(F).");
            break;
        case 0x252600:
            strcpy(strInfo, "真空泵压力传感器信号不合理(F).");
            break;
        case 0x252700:
            strcpy(strInfo, "真空泵压力传感器信号电路电压过低(F).");
            break;
        case 0x252800:
            strcpy(strInfo, "真空泵压力传感器信号电路电压过高(F).");
            break;

        default:
            strcpy(strInfo, "未定义的DTC，请查看DTC列表！");
    }
}
//DTC文本
/* End BUSMASTER generated function - Utils_getDTCInfo */

/* Start BUSMASTER generated function - Utils_getDTCStatus */
void Utils_getDTCStatus(long DTCStatus) {
    bool a = DTCStatus & 0b1;
    bool b = DTCStatus & 0b10;
    bool c = DTCStatus & 0b100;
    bool d = DTCStatus & 0b1000;
    bool e = DTCStatus & 0b10000;
    bool f = DTCStatus & 0b100000;
    bool g = DTCStatus & 0b1000000;
    bool h = DTCStatus & 0b10000000;
    char s0[50] = "";
    char s1[50] = "";
    char s2[50] = "";
    char s3[50] = "";
    char s4[50] = "";
    char s5[50] = "";
    char s6[50] = "";
    char s7[50] = "";

    if (a) { strcpy(s0, "Test failed/"); }
    if (b) { strcpy(s1, "Test failed this operation cycle/"); }
    if (c) { strcpy(s2, "Pending DTC/"); }
    if (d) { strcpy(s3, "Confirmed DTC/"); }
    if (e) { strcpy(s4, "Test not completed since last clear/"); }
    if (f) { strcpy(s5, "Test failed since last clear/"); }
    if (g) { strcpy(s6, "Test not completed this operation cycle/"); }
    if (h) { strcpy(s7, "Warning indicator requested/"); }
    Trace("                %s%s%s%s%s%s%s%s", s0, s1, s2, s3, s4, s5, s6, s7);
}
//DTC文本
/* End BUSMASTER generated function - Utils_getDTCStatus */

/* Start BUSMASTER generated function - Utils_getDTC */
void Utils_getDTC() {
    static long DTC_date;
    static long DTC_status;
    static char DTC_str[100];
//    Trace("DTC_bytes=%d",DTC_bytes);
    mSID = 0x59;
    for (int i = 0; 4 * i + 6 < DTC_bytes; i++) {
        switch (DTC_info[1]) {
            case 0x0A:
                DTC_date = (DTC_info[4 * i + 2] << 16) | (DTC_info[4 * i + 3] << 8) | DTC_info[4 * i + 4];
                DTC_status = DTC_info[4 * i + 5];
            default:
                DTC_date = (DTC_info[4 * i + 3] << 16) | (DTC_info[4 * i + 4] << 8) | DTC_info[4 * i + 5];
                DTC_status = DTC_info[4 * i + 6];
        }
//        DTC_date = (DTC_info[4 * i + 3] << 16) | (DTC_info[4 * i + 4] << 8) | DTC_info[4 * i + 5];
//        DTC_status = DTC_info[4 * i + 6];
        Utils_getDTCInfo(DTC_date, DTC_str);
        Trace(">> DTC %d: %06X %02X %s", i + 1, DTC_date, DTC_status, DTC_str);
        Utils_getDTCStatus(DTC_status);
//        WriteToLogFile(DTC_str);
    }
}
//DTC文本
/* End BUSMASTER generated function - Utils_getDTC */

/* Start BUSMASTER generated function - Utils_getInformation */
void Utils_getInformation() {
    unsigned char str[100], hexnumber[200];
    memset(str, 0, sizeof(str));
    memset(hexnumber, 0, sizeof(hexnumber));
//    FILE *fp;
//    fp = fopen("D:\\information.txt", "a");  //拓展输入到information文本中
//    Trace("mSID=%X,Options=%X,rInformation_type=%X,rInformation_Options=%X",mSID,Options,rInformation_type,rInformation_Options);
    mSID = rInformation_type;//用于校验mSID
    Options = rInformation_Options;//用于校验Options
    if (rInformation_type == 0x62) {
        for (int i = 0; i < byteCount - 3; ++i) {//减去22F190等3字节
            str[i] = rInformation[i + 3];
        }
        Utils_ascii2hex(str, hexnumber);//转为Hex显示的ascii
        switch (rInformation_Options) {
            case 0xf190:
                Trace("22F190 VIN: %s", str);
//                fprintf(fp,"22F190 VIN: %s\n", str);
                break;
            case 0xf187:
                Trace("22F187 零件号: %s", str);
//                fprintf(fp,"22F187 零件号: %s\n", str);
                break;
            case 0xf197:
                Trace("22F197 系统名称: %s", str);
//                fprintf(fp,"22F197 系统名称: %s\n", str);
                break;
            case 0xf18a:
                Trace("22F18A 供应商代码: %s", str);
//                fprintf(fp,"22F18A 供应商代码: %s\n", str);
                break;
            case 0xf193:
                Trace("22F193 硬件号: %s", hexnumber);
//                fprintf(fp,"22F193 硬件号: %s\n", hexnumber);
                break;
            case 0xf195:
                Trace("22F195 软件号: %s", str);
//                fprintf(fp,"22F195 软件号: %s\n", str);
                break;
            case 0xf199:
                Trace("22F199 刷写时间: %s", hexnumber);
//                fprintf(fp,"22F199 刷写时间: %s\n", hexnumber);
                break;
            case 0xf19B:
                Trace("22F19B 标定更改时间: %s", hexnumber);
//                fprintf(fp,"22F19B 标定更改时间: %s\n", hexnumber);
                break;
            case 0xfd5b:
                Trace("22FD5B 硬件版本号: %s", hexnumber);
//                fprintf(fp,"22FD5B 硬件版本号: %s\n", hexnumber);
                break;
            case 0xfd5c:
                Trace("22FD5C 标定数据版本号: %s", str);
//                fprintf(fp,"22FD5C 标定数据版本号: %s\n", str);
                break;
            default:
                break;
        }
    }
    if (rInformation_type == 0x49) {
        for (int i = 0; i < byteCount - 3; ++i) {//减去0904等及标志位3字节
            str[i] = rInformation[i + 3];
        }
        Utils_ascii2hex(str, hexnumber);//转为Hex显示的ascii
        switch (rInformation_Options) {
            case 0x04:
                Trace("0904 CALID: %s", str);
//                fprintf(fp,"0904 CALID: %s\n", str);
                break;
            case 0x06:
//                Trace("0906 CVN: %02X%02X%02X%02X", str[0], str[1], str[2], str[3]);
                Trace("0906 CVN: %s", hexnumber);
//                fprintf(fp,"0906 CVN: %s\n", hexnumber);
                break;
            case 0x02:
                Trace("0902 VIN: %s", str);
//                fprintf(fp,"0902 VIN: %s\n", str);
                break;
            case 0x0A:
                for (int i = 0; i < byteCount - 3; ++i) {//防止00直接结束
                    if (str[i] == 0x00) {
                        str[i] = 0x1f;//改为^_单元分隔符
                    }
                }
                Trace("090A ECUNAME: %s", str);
//                fprintf(fp,"090A ECUNAME: %s\n", str);
//                Trace("byteCount=%d",byteCount);//有00，导致显示不完全
                break;
            case 0x08:
                int IUPR[64];
                float IUPRATE[64];
                memset(IUPR, 0x00, sizeof(IUPR));
                memset(IUPRATE, 0x00, sizeof(IUPRATE));
                IUPR[0] = rInformation[2];//诊断数
                IUPR[1] = str[0] << 8 | str[1];//通用分母
                IUPR[2] = str[2] << 8 | str[3];//点火数
                for (int i = 0; i < IUPR[0] - 2; ++i) {
                    IUPR[i + 3] = str[2 * i + 4] << 8 | str[2 * i + 5];
                }
                for (int i = 0; i < IUPR[0] - 2; ++i) {
                    if (IUPR[2 * i + 4] != 0)
                        IUPRATE[i] = float(IUPR[2 * i + 3]) / float(IUPR[2 * i + 4]);
                    else IUPRATE[i] = 0;
                }
//                Trace("0908 iupt: 诊断数=%d, 通用分母=%d, 点火数=%d, 催化器1=%d/%d, 催化器2=%d/%d, 前氧传感器1=%d/%d, "
//                      "前氧传感器2=%d/%d, EGR/VVT=%d/%d, 二次空气系统=%d/%d, 蒸发泄露诊断=%d/%d, 后氧传感器1=%d/%d, "
//                      "后氧传感器2=%d/%d, 空燃比1=%d/%d, 空燃比2=%d/%d, GPF1=%d/%d, GPF2=%d/%d",
//                      IUPR[0], IUPR[1], IUPR[2], IUPR[3], IUPR[4], IUPR[5], IUPR[6], IUPR[7], IUPR[8], IUPR[9],
//                      IUPR[10], IUPR[11], IUPR[12], IUPR[13], IUPR[14], IUPR[15], IUPR[16], IUPR[17], IUPR[18],
//                      IUPR[19], IUPR[20], IUPR[21], IUPR[22], IUPR[23], IUPR[24], IUPR[25], IUPR[26], IUPR[27],
//                      IUPR[28]);
//                Trace("        iupr: 催化器1=%3.3f, 催化器2=%3.3f, 前氧传感器1=%3.3f, "
//                      "前氧传感器2=%3.3f, EGR/VVT=%3.3f, 二次空气系统=%3.3f, 蒸发泄露诊断=%3.3f, 后氧传感器1=%3.3f, "
//                      "后氧传感器2=%3.3f, 空燃比1=%3.3f, 空燃比2=%3.3f, GPF1=%3.3f, GPF2=%3.3f",
//                      IUPRATE[0], IUPRATE[1], IUPRATE[2], IUPRATE[3], IUPRATE[4], IUPRATE[5], IUPRATE[6], IUPRATE[7],
//                      IUPRATE[8], IUPRATE[9], IUPRATE[10], IUPRATE[11], IUPRATE[12]);
                Trace("0908 iupt: 诊断数=%d, 通用分母=%d, 点火数=%d, 催化器1=%d/%d(%3.3f), 催化器2=%d/%d(%3.3f),"
                      " 前氧传感器1=%d/%d(%3.3f), 前氧传感器2=%d/%d(%3.3f), EGR/VVT=%d/%d(%3.3f), 二次空气系统=%d/%d(%3.3f),"
                      " 蒸发泄露诊断=%d/%d(%3.3f), 后氧传感器1=%d/%d(%3.3f), 后氧传感器2=%d/%d(%3.3f), 空燃比1=%d/%d(%3.3f),"
                      " 空燃比2=%d/%d(%3.3f), GPF1=%d/%d(%3.3f), GPF2=%d/%d(%3.3f)",
                      IUPR[0], IUPR[1], IUPR[2], IUPR[3], IUPR[4], IUPRATE[0], IUPR[5], IUPR[6], IUPRATE[1], IUPR[7],
                      IUPR[8], IUPRATE[2], IUPR[9], IUPR[10], IUPRATE[3], IUPR[11], IUPR[12], IUPRATE[4], IUPR[13],
                      IUPR[14], IUPRATE[5], IUPR[15], IUPR[16], IUPRATE[6], IUPR[17], IUPR[18], IUPRATE[7], IUPR[19],
                      IUPR[20], IUPRATE[8], IUPR[21], IUPR[22], IUPRATE[9], IUPR[23], IUPR[24], IUPRATE[10], IUPR[25],
                      IUPR[26], IUPRATE[11], IUPR[27], IUPR[28], IUPRATE[12]);
//                fprintf(fp,"0908 iupt: 诊断数=%d, 通用分母=%d, 点火数=%d, 催化器1=%d/%d(%3.3f), 催化器2=%d/%d(%3.3f),"
//                           " 前氧传感器1=%d/%d(%3.3f), 前氧传感器2=%d/%d(%3.3f), EGR/VVT=%d/%d(%3.3f), 二次空气系统=%d/%d(%3.3f),"
//                           " 蒸发泄露诊断=%d/%d(%3.3f), 后氧传感器1=%d/%d(%3.3f), 后氧传感器2=%d/%d(%3.3f), 空燃比1=%d/%d(%3.3f),"
//                           " 空燃比2=%d/%d(%3.3f), GPF1=%d/%d(%3.3f), GPF2=%d/%d(%3.3f) \n\n",
//                        IUPR[0], IUPR[1], IUPR[2], IUPR[3], IUPR[4], IUPRATE[0], IUPR[5], IUPR[6], IUPRATE[1], IUPR[7],
//                        IUPR[8], IUPRATE[2], IUPR[9], IUPR[10], IUPRATE[3], IUPR[11], IUPR[12], IUPRATE[4], IUPR[13],
//                        IUPR[14], IUPRATE[5], IUPR[15], IUPR[16], IUPRATE[6], IUPR[17], IUPR[18], IUPRATE[7], IUPR[19],
//                        IUPR[20], IUPRATE[8], IUPR[21], IUPR[22], IUPRATE[9], IUPR[23], IUPR[24], IUPRATE[10], IUPR[25],
//                        IUPR[26], IUPRATE[11], IUPR[27], IUPR[28], IUPRATE[12]);
                break;
            default:
                break;
        }
    }
//    fclose(fp);
    byteCount = 0;
    rInformation_type = 0x00;
    rInformation_Options = 0x00;
}
//Information转换
/* End BUSMASTER generated function - Utils_getInformation */

/* Start BUSMASTER generated function - Utils_checkMessage */
void Utils_checkMessage(STCAN_MSG &msg) {
    static unsigned char msgType;
    msgType = msg.data[0] >> 4;
    switch (msgType) {
        case 0x00:
            if (msg.data[1] != 0x7e) {
                mSID = msg.data[1];
                byteCount = msg.data[0];
                msgCount = 0;
//                if (mSID!=0x7f)//测试使用
//                {
//                    Trace (">> 检测到单帧:SID=%02X,Options=%X",mSID,Options);
//                }

            }
            return;
        case 0x01:
            mSID = msg.data[2];
            Options = msg.data[3];
            byteCount = msg.data[1];
            msgCount = 1;
//            Trace(">> 检测到多帧首帧:SID=%02X", mSID);
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.data[0] = 0x30;
            rstMsg_EMS.data[1] = 0x00;
            rstMsg_EMS.data[2] = 0x00;
            rstMsg_EMS.data[3] = 0xff;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            settimer_CAPL(MSEC_TIMER, msgSend_30, 10);
            return;
        case 0x02:
            if (msgCount > 0) {
//                msgCount++;
                if (msgCount > 0xf) {
                    msgCount++;
                } else { msgCount = (msg.data[0] & 0b1111) + 1; }
//                Trace("流控响应完成：%d", msgCount);
//                Trace("DTC_rst=%02X",DTC_rst);
                if (DTC_rst == True) {
                    for (int i = 0; i < 7; i++) {
                        DTC_info[7 * msgCount - 8 + i] = msg.data[i + 1];
                    }
                }
//                Trace("DTC：%02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X", DTC_info[0], DTC_info[1], DTC_info[2], DTC_info[3], DTC_info[4], DTC_info[5], DTC_info[6], DTC_info[7], DTC_info[8], DTC_info[9], DTC_info[10], DTC_info[11], DTC_info[12], DTC_info[13], DTC_info[14], DTC_info[15]  );
                if (rInformation_rst == True) {
                    for (int i = 0; i < 7; i++) {
                        rInformation[7 * msgCount - 8 + i] = msg.data[i + 1];
                    }
                }
//                Trace("DTC：%02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X %02X", rInformation[0], rInformation[1], rInformation[2], rInformation[3], rInformation[4], rInformation[5], rInformation[6], rInformation[7], rInformation[8], rInformation[9], rInformation[10], rInformation[11], rInformation[12], rInformation[13], rInformation[14], rInformation[15]  );

                return;
            }

        case 0x03:
            mSID = msg.data[0];
            CFTime = msg.data[2];
            CFCount = msg.data[1];
            if (CFTime == 0) { CFTime = 10; }
            Trace("收到流控帧，延时要求%dms", CFTime);
            return;
        default:
            return;
    }
}
//判断单帧、多帧、流控帧，获取SID，报文字节数，流控参数，并自动发送30流控

/* End BUSMASTER generated function - Utils_checkMessage */

/* Start BUSMASTER generated function - Utils_RunFlowControl */
void Utils_RunFlowControl() {
    if (ReSendMsg == True) {
        Step--;
        ReSendMsg = False;
        Trace("ReSendMsg,STEP = %d", Step);
    }

    switch (Mode) {
        case 0x01:
            Utils_doSecAccess();//EMS安全认证
            break;
        case 0x02:
            Utils_doWriteVIN();//EMS写入VIN
            break;
        case 0x0a:
            Utils_doGetInformation();//获取ECU信息
            break;
        case 0x00:
            Utils_initialize();
            Step = 0;
            return;
        default:
            Utils_initialize();
            return;
    }
    Step++;

}
/* End BUSMASTER generated function - Utils_RunFlowControl */

/* Start BUSMASTER generated function - Utils_setTimerWithResp */
void Utils_setTimerWithResp(char *t, long duration, unsigned short wSID) {
    WaitForRespSID = wSID;
    //Trace("WaitForRespSID:%02X",WaitForRespSID)//测试使用
    settimer_CAPL(MSEC_TIMER, t, duration);
}
//配合WaitForRespTimer对mSID进行判断，设定延时及判断SID

/* End BUSMASTER generated function - Utils_setTimerWithResp */

/* Start BUSMASTER generated function - Utils_setTimerWithRespOptions */
void Utils_setTimerWithRespOptions(char *t, long duration, unsigned short wSID, unsigned long wOptions) {
    WaitForRespSID = wSID;
    WaitForRespOptions = wOptions;
    //Trace("WaitForRespSID:%02X",WaitForRespSID)//测试使用
    settimer_CAPL(MSEC_TIMER, t, duration);
}
//配合WaitForRespTimer_Options对mSID及Options进行判断，设定延时及判断SID，Options

/* End BUSMASTER generated function - Utils_setTimerWithRespOptions */

/* Start BUSMASTER generated function - Utils_setTimerWaiting */
void Utils_setTimerWaiting(char *t, long duration, unsigned short wSID, unsigned long wOptions, unsigned char jS) {
    WaitForRespSID = wSID;
    WaitForRespOptions = wOptions;
    jStep = jS;
    //Trace("WaitForRespSID:%02X",WaitForRespSID)//测试使用
    settimer_CAPL(MSEC_TIMER, t, duration);
}
//配合Waiting对mSID及Options，如判断失败则跳步

/* End BUSMASTER generated function - Utils_setTimerWaiting */


/* Start BUSMASTER generated function - Utils_ReadVIN */
short Utils_ReadVIN() {
    static unsigned long vHandle;
    static int i, k, c, check;
    static char checkNum[34] = "0123456789ABCDEFGHJKLMNPRSTUVWXYZ";
    static char chr[2] = "0";
    static int m[33] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 7, 9, 2, 3, 4, 5, 6, 7,
                        8, 9};
    static int n[17] = {8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2};
    k = 0;
    c = 0;
    check = 0;
    vHandle = openfileread_CAPL("D:\\vin.txt", 0);//固定路径
//    vHandle = openfileread_CAPL("vin.txt", 0);
    if (vHandle != 0) {
        filegetstring_CAPL(VIN, sizeof(VIN), vHandle);
        fileclose_CAPL(vHandle);
        for (i = 0; i < 17; i++) {
            VIN[i] = (char) toupper(VIN[i]);
        }
        if (strlen(VIN) != 17) {
            return 0x04; // ErrCode: 0x04 = VIN长度不对
        }

        for (i = 0; i < 17; i++) {
            if ((VIN[i] >= 65 && VIN[i] <= 90 && VIN[i] != 73 && VIN[i] != 79 && VIN[i] != 81) ||
                (VIN[i] >= 48 && VIN[i] <= 57)) {
                vinArr[i] = VIN[i];
                chr[0] = VIN[i];//
                k = strstr_CAPL(checkNum, chr);//
                c += n[i] * m[k];//
            } else {
                return 0x02; //ErrCode: 0x02 = VIN有非法字符
            }
        }
        check = c % 11;//校验位
        if ((check == 10 && vinArr[8] == 88) || check == (short) vinArr[8] - 48) {
            return 0x00; //0x00: 正常
        } else {
            Trace("check:%d,%c", check, vinArr[8]);
            return 0x03;//0x03: 第9位校验位出错
//            return 0x00;//取消校验位
        }
    } else {
        return 0x01;//0x01: 读取失败，请检查VIN.txt路径
    }
}

/* End BUSMASTER generated function - Utils_ReadVIN */

/* Start BUSMASTER generated function - Utils_doSecAccess */
void Utils_doSecAccess() {
//    Trace("STEP = %d", Step);//测试使用
    switch (Step) {
        case 0:
            SetTimerVal(msgSend_3E, testPresentCycle);
            StartTimer(msgSend_3E, 1);
            Trace(">> STEP0：开始进行安全认证");
            Step++;
            Utils_doSecAccess();
            return;
        case 1:
            settimer_CAPL(MSEC_TIMER, msgSend_1001, 200);
            Trace(">> STEP1：进入正常会话模式");
            return;
        case 2:
            settimer_CAPL(MSEC_TIMER, msgSend_1003, 200);
            Trace(">> STEP2：进入拓展会话模式");
            return;
        case 3:
            settimer_CAPL(MSEC_TIMER, msgSend_2701, 200);
            Trace(">> STEP3：安全访问验证");
            return;
        case 4:
            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 200, 0x67, 0x02);/*等待2702响应*/
            Trace(">> STEP4：等待安全认证通过");
            return;
        case 5:
            Trace(">> STEP5：安全访问验证通过");
            Utils_Stop();
            return;
        default:
            Utils_Stop();
            return;
    }


}
/* End BUSMASTER generated function - Utils_doSecAccess */

/* Start BUSMASTER generated function - Utils_checkVIN */
short Utils_checkVIN() {
    static short rst1;
    rst1 = Utils_ReadVIN();
    Trace("读取VIN：%s", VIN);
    switch (rst1) {
        case 0x01:
            Trace("0x01：读取失败，请检查VIN.txt路径");
            return False;
        case 0x02:
            Trace("0x02：VIN有非法字符");
            return False;
        case 0x03:
            Trace("0x03：第9位校验位出错");
            return False;
        case 0x04:
            Trace("0x04：VIN长度不对");
            return False;
        case 0x00:
            Trace("VIN读取完成");
            Trace("o:确认VIN  p:EMS安全认证  q:EMS写入VIN  r:停止  z:获取ECU信息");
            return True;
        default:
            return False;
    }
}
//确认VIN
/* End BUSMASTER generated function - Utils_checkVIN */

/* Start BUSMASTER generated function - Utils_doWriteVIN */
void Utils_doWriteVIN() {
//    Trace("STEP = %d", Step);//测试使用
    switch (Step) {
        case 0:
            SetTimerVal(msgSend_3E, testPresentCycle);
            StartTimer(msgSend_3E, 1);
            Trace(">> STEP0：开始写入VIN");
            Step++;
            Utils_doWriteVIN();
            return;
        case 1:
            settimer_CAPL(MSEC_TIMER, msgSend_1001, 100);
            Trace(">> STEP1：进入正常会话模式");
            return;
        case 2:
            settimer_CAPL(MSEC_TIMER, msgSend_1003, 100);
            Trace(">> STEP2：进入拓展会话模式");
            return;
        case 3:
            settimer_CAPL(MSEC_TIMER, msgSend_2701, 100);
            Trace(">> STEP3：安全访问验证");
            return;
        case 4:
            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 200, 0x67, 0x02);/*等待2702响应*/
            Trace(">> STEP4：等待安全认证通过");
            return;
        case 5:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7e0;
            rstMsg_EMS.data[0] = 0x10;
            rstMsg_EMS.data[1] = 0x14;
            rstMsg_EMS.data[2] = 0x2E;
            rstMsg_EMS.data[3] = 0xF1;
            rstMsg_EMS.data[4] = 0x90;
            rstMsg_EMS.data[5] = vinArr[0];
            rstMsg_EMS.data[6] = vinArr[1];
            rstMsg_EMS.data[7] = vinArr[2];
            Utils_SendMsg();
            Trace(">> STEP5：2EF190首帧");
            Utils_setTimerWithResp(WaitForRespTimer, 40, 0x30);/*马瑞利30响应10ms*/
            return;
        case 6:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7e0;
            rstMsg_EMS.data[0] = 0x21;
            rstMsg_EMS.data[1] = vinArr[3];
            rstMsg_EMS.data[2] = vinArr[4];
            rstMsg_EMS.data[3] = vinArr[5];
            rstMsg_EMS.data[4] = vinArr[6];
            rstMsg_EMS.data[5] = vinArr[7];
            rstMsg_EMS.data[6] = vinArr[8];
            rstMsg_EMS.data[7] = vinArr[9];
            settimer_CAPL(MSEC_TIMER, msgSend, CFTime);
            Trace(">> STEP6：2EF190第二帧");
            return;
        case 7:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7e0;
            rstMsg_EMS.data[0] = 0x22;
            rstMsg_EMS.data[1] = vinArr[10];
            rstMsg_EMS.data[2] = vinArr[11];
            rstMsg_EMS.data[3] = vinArr[12];
            rstMsg_EMS.data[4] = vinArr[13];
            rstMsg_EMS.data[5] = vinArr[14];
            rstMsg_EMS.data[6] = vinArr[15];
            rstMsg_EMS.data[7] = vinArr[16];
            settimer_CAPL(MSEC_TIMER, msgSend, CFTime);
            Trace(">> STEP7：2EF190第三帧");
            return;
        case 8:
            Utils_setTimerWaiting(waiting, 2000, 0x6e, 0xf190, 5);
            Trace(">> STEP8：等待ECU反馈");
            return;
        case 9:
            Trace("流程完成");
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x22;
            rstMsg_EMS.data[2] = 0xf1;
            rstMsg_EMS.data[3] = 0x90;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_Stop();
            return;
        case 99:
            Utils_Stop();
            return;
        default:
            return;
    }
}
/* End BUSMASTER generated function - Utils_doWriteVIN */

//EOL Learn_H40D
/* End BUSMASTER generated function - Utils_doEOL_H40D */


/* End BUSMASTER generated function - Utils_doReLearningKey_H40D */

/* Start BUSMASTER generated function - Utils_doGetInformation */
void Utils_doGetInformation() {
//    Trace("STEP = %d", Step);
    switch (Step) {
        case 0:
//            SetTimerVal(msgSend_3E, testPresentCycle);//取消3E，减少对30的影响
//            StartTimer(msgSend_3E, 1);
//            Step++;
//            Utils_doGetInformation();
            settimer_CAPL(MSEC_TIMER, msgSend_1003, 200);
            return;
        case 1:
            Utils_setTimerWaiting(waiting, 200, 0xff, 0xff, ++Step);//等待5003响应
            return;
        case 2:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x22;
            rstMsg_EMS.data[2] = 0xf1;
            rstMsg_EMS.data[3] = 0x90;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x62,0xf190);//延时需要大于checkInformation的延时,容易导致7F Pending如需要校验最好还是拆2步，以免重新发送
            return;
        case 3:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x22;
            rstMsg_EMS.data[2] = 0xf1;
            rstMsg_EMS.data[3] = 0x87;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x62,0xf187);
            return;
        case 4:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x22;
            rstMsg_EMS.data[2] = 0xf1;
            rstMsg_EMS.data[3] = 0x97;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x62,0xf197);
            return;
        case 5:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x22;
            rstMsg_EMS.data[2] = 0xf1;
            rstMsg_EMS.data[3] = 0x8a;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x62,0xf18a);
            return;
        case 6:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x22;
            rstMsg_EMS.data[2] = 0xf1;
            rstMsg_EMS.data[3] = 0x93;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x62,0xf193);
            return;
        case 7:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x22;
            rstMsg_EMS.data[2] = 0xf1;
            rstMsg_EMS.data[3] = 0x95;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x62,0xf195);
            return;
        case 8:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x22;
            rstMsg_EMS.data[2] = 0xf1;
            rstMsg_EMS.data[3] = 0x99;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x62,0xf199);
            return;
        case 9:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x22;
            rstMsg_EMS.data[2] = 0xf1;
            rstMsg_EMS.data[3] = 0x9B;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x62,0xf199);
            return;
        case 10:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x22;
            rstMsg_EMS.data[2] = 0xFD;
            rstMsg_EMS.data[3] = 0x5B;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x62,0xf199);
            return;
        case 11:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x22;
            rstMsg_EMS.data[2] = 0xFD;
            rstMsg_EMS.data[3] = 0x5C;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x62,0xf199);
            return;
        case 12:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7DF;
            rstMsg_EMS.data[0] = 0x02;
            rstMsg_EMS.data[1] = 0x09;
            rstMsg_EMS.data[2] = 0x04;
            rstMsg_EMS.data[3] = 0xff;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            rstMsg_EMS.id = 0x7E0;
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x49,0x04);
            return;
        case 13:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7DF;
            rstMsg_EMS.data[0] = 0x02;
            rstMsg_EMS.data[1] = 0x09;
            rstMsg_EMS.data[2] = 0x06;
            rstMsg_EMS.data[3] = 0xff;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            rstMsg_EMS.id = 0x7E0;
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x49,0x06);
            return;
        case 14:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7DF;
            rstMsg_EMS.data[0] = 0x02;
            rstMsg_EMS.data[1] = 0x09;
            rstMsg_EMS.data[2] = 0x02;
            rstMsg_EMS.data[3] = 0xff;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            rstMsg_EMS.id = 0x7E0;
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x49,0x02);
            return;
        case 15:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7DF;
            rstMsg_EMS.data[0] = 0x02;
            rstMsg_EMS.data[1] = 0x09;
            rstMsg_EMS.data[2] = 0x0a;
            rstMsg_EMS.data[3] = 0xff;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            rstMsg_EMS.id = 0x7E0;
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x49,0x0a);
            return;
        case 16:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7DF;
            rstMsg_EMS.data[0] = 0x02;
            rstMsg_EMS.data[1] = 0x09;
            rstMsg_EMS.data[2] = 0x08;
            rstMsg_EMS.data[3] = 0xff;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            rstMsg_EMS.id = 0x7E0;
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x49,0x08);
            return;
        case 17:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E0;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x19;
            rstMsg_EMS.data[2] = 0x02;
            rstMsg_EMS.data[3] = 0x0c;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x59,0x02);//延时需要大于checkDTC的延时
            return;
        case 18:
            rstMsg_EMS.dlc = 8;
            rstMsg_EMS.id = 0x7E1;
            rstMsg_EMS.data[0] = 0x03;
            rstMsg_EMS.data[1] = 0x19;
            rstMsg_EMS.data[2] = 0x02;
            rstMsg_EMS.data[3] = 0x0c;
            rstMsg_EMS.data[4] = 0xff;
            rstMsg_EMS.data[5] = 0xff;
            rstMsg_EMS.data[6] = 0xff;
            rstMsg_EMS.data[7] = 0xff;
            Utils_SendMsg();
            Utils_setTimerWaiting(waiting, 500, 0xff, 0xff, ++Step);
//            Utils_setTimerWithRespOptions(WaitForRespTimer_Options, 500, 0x59,0x02);//延时需要大于checkDTC的延时
            return;
        case 19:
            rstMsg_EMS.id = 0x7E0;
            Utils_Stop();
            return;
        case 99:
            Utils_Stop();
            return;
        default:
            return;
    }

}
/* End BUSMASTER generated function - Utils_doGetInformation */

/* Start BUSMASTER generated function - Utils_initialize */
void Utils_initialize() {
    Mode = 0x00;
    ReSendMsg = False;
    Step = 0;
    mSID = 0x00;
    Options = 0x00;
    IMMO_Status = 0xff;
    Vehicle_Status = 0xff;
    StopTimer(checkDTC);
    StopTimer(checkInformation);
    StopTimer(msgSend);
    StopTimer(msgSend_1001);
    StopTimer(msgSend_1003);
    StopTimer(msgSend_1101);
    StopTimer(msgSend_2701);
    StopTimer(msgSend_3E);
    StopTimer(msgSend_30);
    StopTimer(msgSend_CF);
    StopTimer(msgSend_IGOFF);
    StopTimer(msgSend_IGON);
    StopTimer(timer_Stop);
    StopTimer(WaitForRespTimer);
    StopTimer(WaitForRespTimer_Options);
    StopTimer(waiting);
}
/* End BUSMASTER generated function - Utils_initialize */

/* Start BUSMASTER generated function - Utils_PreStart */
void Utils_PreStart() {
    Utils_initialize();
}
/* End BUSMASTER generated function - Utils_PreStart */

/* Start BUSMASTER generated function - Utils_ascii2hex */
void Utils_ascii2hex(const unsigned char chr[], unsigned char hexnumber[]) {
    static long a, b;
    for (int i = 0; i < byteCount - 3; ++i) {
        a = chr[i] >> 4 & 0x0F;
        b = chr[i] & 0x0F;
        if (a <= 0x09) {
            a += 0x30;
        } else {
            a += 0x37;
        }
        if (b <= 0x09) {
            b += 0x30;
        } else {
            b += 0x37;
        }
        hexnumber[2 * i] = a;
        hexnumber[2 * i + 1] = b;
    }
}
/* End BUSMASTER generated function - Utils_ascii2hex */



/* Start BUSMASTER generated function - OnBus_Connect */
void OnBus_Connect() {
    Utils_initialize();
    initialize(&rstMsg_EMS, 0x7e0, false, 0, 1);
    initialize(&present_EMS, 0x7e0, false, 8, 1, 0x02, 0x3e, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff);
    Utils_checkVIN();
}
/* End BUSMASTER generated function - OnBus_Connect */


/* Start BUSMASTER generated function - OnKey_o */
void OnKey_o() {
    Utils_initialize();
    Utils_checkVIN();//读取VIN
}
/* End BUSMASTER generated function - OnKey_o */

/* Start BUSMASTER generated function - OnKey_p */
void OnKey_p() {
    rstMsg_EMS.id = 0x7e0;//EMS
    present_EMS.id = 0x7e0;//EMS
//    rstMsg_EMS.cluster = 1;
//    present_EMS.cluster = 1;
    Utils_initialize();
    settimer_CAPL(MSEC_TIMER, timer_Stop, 2500);//超时
    Mode = 0x01;//
    if (Utils_checkVIN() == True) {
        Utils_RunFlowControl();
    }
}
/* End BUSMASTER generated function - OnKey_p */

/* Start BUSMASTER generated function - OnKey_q */
void OnKey_q() {
    rstMsg_EMS.id = 0x7e0;//EMS
    present_EMS.id = 0x7e0;//EMS
//    rstMsg_EMS.cluster = 1;
//    present_EMS.cluster = 1;
    Utils_initialize();
    settimer_CAPL(MSEC_TIMER, timer_Stop, 4000);//超时
//    Step = 5;//跳过安全访问改为5
//    CFSend = 0x03;//第3帧开始补帧
    Mode = 0x02;//EMS写入VIN
    if (Utils_checkVIN() == True) {
        Utils_RunFlowControl();
    }
}
/* End BUSMASTER generated function - OnKey_q */

/* Start BUSMASTER generated function - OnKey_r */
void OnKey_r() {
    Utils_initialize();
//    settimer_CAPL(MSEC_TIMER, timer_Stop, 50);
    Trace("停止");
}


/* Start BUSMASTER generated function - OnKey_z */
void OnKey_z() {
    StopTimer(msgSend_3E);
    rstMsg_EMS.id = 0x7E0;//EMS
    present_EMS.id = 0x7E0;//EMS
//    rstMsg_EMS.cluster = 1;
//    present_EMS.cluster = 1;
    Utils_initialize();
    settimer_CAPL(MSEC_TIMER, timer_Stop, 10000);//超时
    Mode = 0x0a;//get information
    Utils_RunFlowControl();
}
/* End BUSMASTER generated function - OnKey_z */
